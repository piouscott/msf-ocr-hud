<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>MSF Portrait Extractor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 20px;
    }
    h1 { color: #00d4ff; margin-bottom: 20px; }

    .instructions {
      background: #2d2d44;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .instructions h2 { font-size: 14px; margin-bottom: 10px; color: #00d4ff; }
    .instructions ol { margin-left: 20px; font-size: 13px; line-height: 1.8; }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    .btn-primary { background: #00d4ff; color: #1a1a2e; }
    .btn-success { background: #51cf66; color: #1a1a2e; }
    .btn-secondary { background: #2d2d44; color: #ccc; border: 1px solid #444; }
    .btn-warning { background: #ffd43b; color: #1a1a2e; }

    #drop-zone {
      border: 2px dashed #444;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 20px;
      transition: border-color 0.2s;
    }
    #drop-zone.dragover { border-color: #00d4ff; }
    #drop-zone p { color: #888; }

    .preview-container {
      position: relative;
      margin-bottom: 20px;
      overflow: auto;
      max-height: 500px;
      border: 1px solid #444;
      border-radius: 8px;
    }

    #preview {
      display: block;
    }

    #grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    #status {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 20px;
      display: none;
    }
    #status.success { display: block; background: #51cf66; color: #1a1a2e; }
    #status.error { display: block; background: #ff6b6b; color: #fff; }
    #status.info { display: block; background: #00d4ff; color: #1a1a2e; }

    /* Config panel */
    .config-panel {
      background: #2d2d44;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .config-panel.visible { display: block; }

    .config-row {
      display: flex;
      gap: 20px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .config-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .config-item label {
      font-size: 12px;
      color: #888;
      min-width: 80px;
    }

    .config-item input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a2e;
      color: #fff;
      font-size: 12px;
    }

    .config-item input[type="range"] {
      width: 120px;
    }

    .config-item span {
      font-size: 11px;
      color: #00d4ff;
      min-width: 30px;
    }

    #portraits-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
      margin-bottom: 20px;
    }

    .portrait-card {
      background: #2d2d44;
      border-radius: 8px;
      padding: 8px;
      text-align: center;
      position: relative;
    }

    .portrait-card.empty {
      opacity: 0.3;
    }

    .portrait-card img {
      width: 64px;
      height: 64px;
      border-radius: 4px;
      margin-bottom: 6px;
      border: 2px solid transparent;
    }

    .portrait-card.selected img {
      border-color: #00d4ff;
    }

    .portrait-card input {
      width: 100%;
      padding: 3px 6px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a2e;
      color: #fff;
      font-size: 10px;
      text-align: center;
    }

    .portrait-card .hash {
      font-size: 8px;
      color: #555;
      margin-top: 3px;
      word-break: break-all;
    }

    .portrait-card .ocr-raw {
      font-size: 8px;
      color: #ffd43b;
      margin-top: 2px;
      word-break: break-all;
      opacity: 0.7;
    }

    .portrait-card .match-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: bold;
    }

    .match-badge.match-high {
      background: #51cf66;
      color: #1a1a2e;
    }

    .match-badge.match-medium {
      background: #ffd43b;
      color: #1a1a2e;
    }

    .match-badge.match-low {
      background: #ff922b;
      color: #1a1a2e;
    }

    .match-badge.match-none {
      background: #ff6b6b;
      color: #fff;
    }

    .portrait-card .index {
      font-size: 9px;
      color: #666;
      margin-bottom: 4px;
    }

    #output {
      background: #0d0d1a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow: auto;
      white-space: pre-wrap;
      display: none;
    }

    .stats {
      background: #2d2d44;
      padding: 10px 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 13px;
      display: none;
    }

    .stats.visible { display: block; }

    /* Mode selection manuelle */
    .manual-mode {
      background: #3d2d44;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .manual-mode.visible { display: block; }

    .manual-mode h3 {
      color: #ffd43b;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .manual-mode p {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 10px;
    }

    #canvas-container {
      position: relative;
      display: inline-block;
      cursor: crosshair;
    }

    #selection-canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <!-- Tesseract.js pour OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <h1>MSF Portrait Extractor</h1>

  <div class="instructions">
    <h2>Mode d'emploi</h2>
    <ol>
      <li>Charger une capture d'ecran de la page des personnages MSF</li>
      <li><b>Mode Auto</b>: Ajuster les parametres de grille puis "Detecter"</li>
      <li><b>Mode Manuel</b>: Cliquer sur chaque portrait pour l'extraire</li>
      <li>Remplir les noms des personnages</li>
      <li>Exporter en JSON</li>
    </ol>
  </div>

  <div class="controls">
    <button class="btn-primary" id="btn-load">Charger image</button>
    <button class="btn-secondary" id="btn-toggle-config">Config grille</button>
    <button class="btn-warning" id="btn-auto-params">Auto-params</button>
    <button class="btn-secondary" id="btn-detect">Detecter portraits</button>
    <button class="btn-primary" id="btn-ocr-names">OCR Noms</button>
    <button class="btn-warning" id="btn-manual">Mode manuel</button>
    <button class="btn-success" id="btn-export">Exporter JSON</button>
    <button class="btn-secondary" id="btn-copy">Copier</button>
    <button class="btn-secondary" id="btn-clear">Effacer tout</button>
  </div>

  <input type="file" id="file-input" accept="image/*" style="display:none">

  <div id="drop-zone">
    <p>Glisser-deposer une image ici<br>ou cliquer sur "Charger image"</p>
  </div>

  <div class="config-panel" id="config-panel">
    <div style="font-size:12px; color:#51cf66; margin-bottom:8px;">Zone de la grille (marges):</div>
    <div class="config-row">
      <div class="config-item">
        <label>Colonnes:</label>
        <input type="number" id="cfg-cols" value="12" min="1" max="20">
      </div>
      <div class="config-item">
        <label>Lignes:</label>
        <input type="number" id="cfg-rows" value="5" min="1" max="20">
      </div>
    </div>
    <div class="config-row">
      <div class="config-item">
        <label>Marge gauche:</label>
        <input type="range" id="cfg-startX" value="0" min="0" max="30">
        <span id="cfg-startX-val">0%</span>
      </div>
      <div class="config-item">
        <label>Marge haute:</label>
        <input type="range" id="cfg-startY" value="0" min="0" max="30">
        <span id="cfg-startY-val">0%</span>
      </div>
    </div>
    <div class="config-row">
      <div class="config-item">
        <label>Largeur grille:</label>
        <input type="range" id="cfg-gridWidth" value="100" min="70" max="100">
        <span id="cfg-gridWidth-val">100%</span>
      </div>
      <div class="config-item">
        <label>Hauteur grille:</label>
        <input type="range" id="cfg-gridHeight" value="100" min="70" max="100">
        <span id="cfg-gridHeight-val">100%</span>
      </div>
    </div>
    <div class="config-row">
      <div class="config-item">
        <label>Ecart lignes:</label>
        <input type="range" id="cfg-rowGap" value="0" min="-10" max="20">
        <span id="cfg-rowGap-val">0%</span>
      </div>
    </div>

    <div style="margin-top:15px; padding-top:15px; border-top:1px solid #444;">
      <div style="font-size:12px; color:#00d4ff; margin-bottom:8px;">Position portrait dans la cellule:</div>
      <div class="config-row">
        <div class="config-item">
          <label>Offset X:</label>
          <input type="range" id="cfg-offsetX" value="50" min="0" max="100">
          <span id="cfg-offsetX-val">50%</span>
        </div>
        <div class="config-item">
          <label>Offset Y:</label>
          <input type="range" id="cfg-offsetY" value="8" min="0" max="100">
          <span id="cfg-offsetY-val">8%</span>
        </div>
      </div>
      <div class="config-row">
        <div class="config-item">
          <label>Largeur %:</label>
          <input type="range" id="cfg-widthPct" value="75" min="20" max="100">
          <span id="cfg-widthPct-val">75%</span>
        </div>
        <div class="config-item">
          <label>Hauteur %:</label>
          <input type="range" id="cfg-heightPct" value="55" min="20" max="100">
          <span id="cfg-heightPct-val">55%</span>
        </div>
      </div>
    </div>
    <button class="btn-secondary" id="btn-preview-grid" style="margin-top:10px">Previsualiser grille</button>

    <div style="margin-top:15px; padding-top:15px; border-top:1px solid #444;">
      <div style="font-size:12px; color:#ffd43b; margin-bottom:8px;">Zone texte (nom du personnage):</div>
      <div class="config-row">
        <div class="config-item">
          <label>Offset X nom:</label>
          <input type="range" id="cfg-nameOffsetX" value="5" min="0" max="30">
          <span id="cfg-nameOffsetX-val">5%</span>
        </div>
        <div class="config-item">
          <label>Largeur nom:</label>
          <input type="range" id="cfg-nameWidth" value="90" min="50" max="100">
          <span id="cfg-nameWidth-val">90%</span>
        </div>
      </div>
      <div class="config-row">
        <div class="config-item">
          <label>Offset Y nom:</label>
          <input type="range" id="cfg-nameOffsetY" value="82" min="0" max="100">
          <span id="cfg-nameOffsetY-val">82%</span>
        </div>
        <div class="config-item">
          <label>Hauteur nom:</label>
          <input type="range" id="cfg-nameHeight" value="10" min="5" max="25">
          <span id="cfg-nameHeight-val">10%</span>
        </div>
      </div>
    </div>
  </div>

  <div class="manual-mode" id="manual-mode">
    <h3>Mode selection manuelle</h3>
    <p>Cliquez sur l'image pour selectionner un portrait (carre 64x64). Entrez le nom puis cliquez sur le suivant.</p>
    <div class="config-item" style="margin-bottom:10px">
      <label>Taille selection:</label>
      <input type="number" id="manual-size" value="64" min="32" max="128" style="width:60px">
      <span>px</span>
    </div>
    <button class="btn-secondary" id="btn-exit-manual">Quitter mode manuel</button>
  </div>

  <div class="preview-container" id="preview-container" style="display:none">
    <div id="canvas-container">
      <canvas id="preview"></canvas>
      <canvas id="grid-overlay"></canvas>
      <canvas id="selection-canvas"></canvas>
    </div>
  </div>

  <div id="status"></div>

  <div class="stats" id="stats">
    Portraits: <span id="count">0</span> | Nommes: <span id="named-count">0</span>
  </div>

  <div id="portraits-grid"></div>

  <div id="output"></div>

  <script>
    let loadedImage = null;
    let extractedPortraits = [];
    let isManualMode = false;

    // Config - valeurs optimisees pour les cartes MSF
    // Structure carte MSF: portrait carre en haut (~55% de la cellule), nom en bas
    const config = {
      cols: 12,
      rows: 5,
      startX: 0,        // % marge gauche avant la grille
      startY: 0,        // % marge haute avant la grille
      gridWidth: 100,   // % largeur totale de la grille (100 = toute l'image)
      gridHeight: 100,  // % hauteur totale de la grille
      rowGap: 0,        // % espacement supplementaire entre les lignes
      portraitSize: 80, // % (legacy, non utilise si widthPct/heightPct definis)
      offsetX: 50,      // % position horizontale du centre dans la cellule
      offsetY: 8,       // % position verticale du haut dans la cellule (petit decalage)
      widthPct: 75,     // % largeur du portrait par rapport a la cellule
      heightPct: 55,    // % hauteur du portrait par rapport a la cellule (carre visuellement)
      nameOffsetX: 5,   // % position X du texte du nom dans la cellule
      nameWidth: 90,    // % largeur de la zone de texte
      nameOffsetY: 82,  // % position Y du texte du nom dans la cellule
      nameHeight: 10    // % hauteur de la zone de texte
    };

    // OCR worker
    let ocrWorker = null;

    // Base de donnees des noms de personnages MSF (chargee depuis l'API)
    let knownNames = [];
    let nameToId = {};

    // Charger les noms connus au demarrage
    async function loadKnownNames() {
      try {
        const response = await fetch('../data/ocr-names.json');
        const data = await response.json();
        knownNames = data.names || [];
        nameToId = data.nameToId || {};
        console.log(`[OCR] ${knownNames.length} noms de personnages charges`);
      } catch (e) {
        console.warn('[OCR] Impossible de charger ocr-names.json:', e);
        knownNames = [];
        nameToId = {};
      }
    }
    loadKnownNames();

    /**
     * Calcule la distance de Levenshtein entre deux chaines
     */
    function levenshtein(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      const matrix = [];
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // substitution
              matrix[i][j - 1] + 1,     // insertion
              matrix[i - 1][j] + 1      // deletion
            );
          }
        }
      }

      return matrix[b.length][a.length];
    }

    /**
     * Trouve le meilleur match pour un nom OCR dans la base de noms connus
     * Retourne {name, charId, similarity} ou null si aucun match acceptable
     */
    function findBestMatch(ocrName, threshold = 0.6) {
      if (!ocrName || knownNames.length === 0) return null;

      const normalized = ocrName.toUpperCase().trim();

      // Match exact
      if (knownNames.includes(normalized)) {
        return {
          name: normalized,
          charId: nameToId[normalized] || null,
          similarity: 100
        };
      }

      // Fuzzy matching
      let bestMatch = null;
      let bestScore = 0;

      for (const known of knownNames) {
        const distance = levenshtein(normalized, known);
        const maxLen = Math.max(normalized.length, known.length);
        const similarity = (maxLen - distance) / maxLen;

        if (similarity > bestScore && similarity >= threshold) {
          bestScore = similarity;
          bestMatch = {
            name: known,
            charId: nameToId[known] || null,
            similarity: Math.round(similarity * 100)
          };
        }
      }

      return bestMatch;
    }

    // Elements DOM
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const previewContainer = document.getElementById('preview-container');
    const previewCanvas = document.getElementById('preview');
    const gridOverlay = document.getElementById('grid-overlay');
    const selectionCanvas = document.getElementById('selection-canvas');
    const status = document.getElementById('status');
    const stats = document.getElementById('stats');
    const countSpan = document.getElementById('count');
    const namedCountSpan = document.getElementById('named-count');
    const grid = document.getElementById('portraits-grid');
    const output = document.getElementById('output');
    const configPanel = document.getElementById('config-panel');
    const manualMode = document.getElementById('manual-mode');

    // ===== Gestion des fichiers =====

    document.getElementById('btn-load').addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
      if (e.target.files[0]) loadImage(e.target.files[0]);
    });

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
    });

    function loadImage(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          loadedImage = img;

          // Dessiner sur le canvas
          previewCanvas.width = img.width;
          previewCanvas.height = img.height;
          gridOverlay.width = img.width;
          gridOverlay.height = img.height;
          selectionCanvas.width = img.width;
          selectionCanvas.height = img.height;

          const ctx = previewCanvas.getContext('2d');
          ctx.drawImage(img, 0, 0);

          previewContainer.style.display = 'block';
          dropZone.style.display = 'none';

          setStatus(`Image: ${img.width}x${img.height}`, 'success');
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // ===== Config =====

    document.getElementById('btn-toggle-config').addEventListener('click', () => {
      configPanel.classList.toggle('visible');
    });

    // Config inputs
    document.getElementById('cfg-cols').addEventListener('change', (e) => {
      config.cols = parseInt(e.target.value) || 12;
    });
    document.getElementById('cfg-rows').addEventListener('change', (e) => {
      config.rows = parseInt(e.target.value) || 5;
    });

    // Marges de grille
    document.getElementById('cfg-startX').addEventListener('input', (e) => {
      config.startX = parseInt(e.target.value);
      document.getElementById('cfg-startX-val').textContent = config.startX + '%';
    });
    document.getElementById('cfg-startY').addEventListener('input', (e) => {
      config.startY = parseInt(e.target.value);
      document.getElementById('cfg-startY-val').textContent = config.startY + '%';
    });
    document.getElementById('cfg-gridWidth').addEventListener('input', (e) => {
      config.gridWidth = parseInt(e.target.value);
      document.getElementById('cfg-gridWidth-val').textContent = config.gridWidth + '%';
    });
    document.getElementById('cfg-gridHeight').addEventListener('input', (e) => {
      config.gridHeight = parseInt(e.target.value);
      document.getElementById('cfg-gridHeight-val').textContent = config.gridHeight + '%';
    });
    document.getElementById('cfg-rowGap').addEventListener('input', (e) => {
      config.rowGap = parseInt(e.target.value);
      document.getElementById('cfg-rowGap-val').textContent = config.rowGap + '%';
    });

    // Position portrait dans cellule
    document.getElementById('cfg-offsetX').addEventListener('input', (e) => {
      config.offsetX = parseInt(e.target.value);
      document.getElementById('cfg-offsetX-val').textContent = config.offsetX + '%';
    });
    document.getElementById('cfg-offsetY').addEventListener('input', (e) => {
      config.offsetY = parseInt(e.target.value);
      document.getElementById('cfg-offsetY-val').textContent = config.offsetY + '%';
    });
    document.getElementById('cfg-widthPct').addEventListener('input', (e) => {
      config.widthPct = parseInt(e.target.value);
      document.getElementById('cfg-widthPct-val').textContent = config.widthPct + '%';
    });
    document.getElementById('cfg-heightPct').addEventListener('input', (e) => {
      config.heightPct = parseInt(e.target.value);
      document.getElementById('cfg-heightPct-val').textContent = config.heightPct + '%';
    });
    document.getElementById('cfg-nameOffsetX').addEventListener('input', (e) => {
      config.nameOffsetX = parseInt(e.target.value);
      document.getElementById('cfg-nameOffsetX-val').textContent = config.nameOffsetX + '%';
    });
    document.getElementById('cfg-nameWidth').addEventListener('input', (e) => {
      config.nameWidth = parseInt(e.target.value);
      document.getElementById('cfg-nameWidth-val').textContent = config.nameWidth + '%';
    });
    document.getElementById('cfg-nameOffsetY').addEventListener('input', (e) => {
      config.nameOffsetY = parseInt(e.target.value);
      document.getElementById('cfg-nameOffsetY-val').textContent = config.nameOffsetY + '%';
    });
    document.getElementById('cfg-nameHeight').addEventListener('input', (e) => {
      config.nameHeight = parseInt(e.target.value);
      document.getElementById('cfg-nameHeight-val').textContent = config.nameHeight + '%';
    });

    document.getElementById('btn-preview-grid').addEventListener('click', previewGrid);

    // ===== Auto-detection des parametres =====
    document.getElementById('btn-auto-params').addEventListener('click', autoDetectParams);

    async function autoDetectParams() {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }

      setStatus('Analyse de l\'image...', 'info');

      try {
        // Analyser l'image pour detecter la structure des cartes
        const ctx = previewCanvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, loadedImage.width, loadedImage.height);

        // Detecter les bordures verticales (lignes sombres entre les cartes)
        const verticalEdges = detectVerticalEdges(imageData, loadedImage.width, loadedImage.height);

        // Detecter les bordures horizontales
        const horizontalEdges = detectHorizontalEdges(imageData, loadedImage.width, loadedImage.height);

        // Estimer le nombre de colonnes et lignes
        const estimatedCols = Math.max(1, verticalEdges.length - 1) || config.cols;
        const estimatedRows = Math.max(1, horizontalEdges.length - 1) || config.rows;

        // Si detection reussie, mettre a jour la config
        if (verticalEdges.length > 1 && horizontalEdges.length > 1) {
          config.cols = estimatedCols;
          config.rows = estimatedRows;
          document.getElementById('cfg-cols').value = config.cols;
          document.getElementById('cfg-rows').value = config.rows;

          setStatus(`Detecte: ${config.cols} colonnes x ${config.rows} lignes. Ajustez les autres parametres si besoin.`, 'success');
        } else {
          // Utiliser des valeurs par defaut optimisees pour MSF
          setStatus('Auto-detection partielle. Parametres MSF optimises appliques.', 'info');
        }

        // Appliquer les parametres optimises pour MSF et afficher la grille
        applyMSFDefaults();
        configPanel.classList.add('visible');
        previewGrid();

      } catch (e) {
        console.error('Erreur auto-detection:', e);
        setStatus('Erreur analyse. Parametres MSF par defaut appliques.', 'error');
        applyMSFDefaults();
        previewGrid();
      }
    }

    function applyMSFDefaults() {
      // Appliquer les valeurs optimisees pour MSF
      // Marges de grille (l'image MSF a un peu de marge)
      config.startX = 1;
      config.startY = 0;
      config.gridWidth = 98;
      config.gridHeight = 100;
      config.rowGap = 0;

      // Position portrait dans cellule
      config.offsetX = 50;
      config.offsetY = 5;
      config.widthPct = 70;
      config.heightPct = 50;

      // Zone texte (nom)
      config.nameOffsetX = 5;
      config.nameWidth = 90;
      config.nameOffsetY = 80;
      config.nameHeight = 10;

      // Mettre a jour les sliders - marges
      document.getElementById('cfg-startX').value = config.startX;
      document.getElementById('cfg-startX-val').textContent = config.startX + '%';
      document.getElementById('cfg-startY').value = config.startY;
      document.getElementById('cfg-startY-val').textContent = config.startY + '%';
      document.getElementById('cfg-gridWidth').value = config.gridWidth;
      document.getElementById('cfg-gridWidth-val').textContent = config.gridWidth + '%';
      document.getElementById('cfg-gridHeight').value = config.gridHeight;
      document.getElementById('cfg-gridHeight-val').textContent = config.gridHeight + '%';
      document.getElementById('cfg-rowGap').value = config.rowGap;
      document.getElementById('cfg-rowGap-val').textContent = config.rowGap + '%';

      // Mettre a jour les sliders - portrait
      document.getElementById('cfg-offsetX').value = config.offsetX;
      document.getElementById('cfg-offsetX-val').textContent = config.offsetX + '%';
      document.getElementById('cfg-offsetY').value = config.offsetY;
      document.getElementById('cfg-offsetY-val').textContent = config.offsetY + '%';
      document.getElementById('cfg-widthPct').value = config.widthPct;
      document.getElementById('cfg-widthPct-val').textContent = config.widthPct + '%';
      document.getElementById('cfg-heightPct').value = config.heightPct;
      document.getElementById('cfg-heightPct-val').textContent = config.heightPct + '%';

      // Mettre a jour les sliders - zone texte
      document.getElementById('cfg-nameOffsetX').value = config.nameOffsetX;
      document.getElementById('cfg-nameOffsetX-val').textContent = config.nameOffsetX + '%';
      document.getElementById('cfg-nameWidth').value = config.nameWidth;
      document.getElementById('cfg-nameWidth-val').textContent = config.nameWidth + '%';
      document.getElementById('cfg-nameOffsetY').value = config.nameOffsetY;
      document.getElementById('cfg-nameOffsetY-val').textContent = config.nameOffsetY + '%';
      document.getElementById('cfg-nameHeight').value = config.nameHeight;
      document.getElementById('cfg-nameHeight-val').textContent = config.nameHeight + '%';
    }

    function detectVerticalEdges(imageData, width, height) {
      const edges = [];
      const data = imageData.data;
      const threshold = 30; // Difference de luminosite pour detecter un bord
      const minGap = width / 20; // Espace minimum entre deux bords

      // Scanner le tiers superieur de l'image (la ou les portraits sont)
      const scanHeight = Math.floor(height / 3);
      const startY = Math.floor(height / 6);

      for (let x = 5; x < width - 5; x++) {
        let edgeScore = 0;

        // Verifier si c'est une ligne verticale sombre
        for (let y = startY; y < startY + scanHeight; y += 5) {
          const idx = (y * width + x) * 4;
          const leftIdx = (y * width + x - 3) * 4;
          const rightIdx = (y * width + x + 3) * 4;

          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const leftBrightness = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
          const rightBrightness = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;

          // Bord detecte si la colonne est plus sombre que ses voisines
          if (brightness < 50 && (leftBrightness - brightness > threshold || rightBrightness - brightness > threshold)) {
            edgeScore++;
          }
        }

        // Si assez de points de bord detectes
        if (edgeScore > scanHeight / 20) {
          // Verifier qu'on est assez loin du dernier bord
          if (edges.length === 0 || x - edges[edges.length - 1] > minGap) {
            edges.push(x);
          }
        }
      }

      return edges;
    }

    function detectHorizontalEdges(imageData, width, height) {
      const edges = [];
      const data = imageData.data;
      const threshold = 30;
      const minGap = height / 10;

      // Scanner le centre horizontal de l'image
      const scanWidth = Math.floor(width / 3);
      const startX = Math.floor(width / 3);

      for (let y = 5; y < height - 5; y++) {
        let edgeScore = 0;

        for (let x = startX; x < startX + scanWidth; x += 5) {
          const idx = (y * width + x) * 4;
          const topIdx = ((y - 3) * width + x) * 4;
          const bottomIdx = ((y + 3) * width + x) * 4;

          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const topBrightness = (data[topIdx] + data[topIdx + 1] + data[topIdx + 2]) / 3;
          const bottomBrightness = (data[bottomIdx] + data[bottomIdx + 1] + data[bottomIdx + 2]) / 3;

          if (brightness < 50 && (topBrightness - brightness > threshold || bottomBrightness - brightness > threshold)) {
            edgeScore++;
          }
        }

        if (edgeScore > scanWidth / 20) {
          if (edges.length === 0 || y - edges[edges.length - 1] > minGap) {
            edges.push(y);
          }
        }
      }

      return edges;
    }

    function previewGrid() {
      if (!loadedImage) return;

      const ctx = gridOverlay.getContext('2d');
      ctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);

      // Zone de grille (avec marges)
      const gridStartX = loadedImage.width * (config.startX / 100);
      const gridStartY = loadedImage.height * (config.startY / 100);
      const gridW = loadedImage.width * (config.gridWidth / 100);
      const gridH = loadedImage.height * (config.gridHeight / 100);

      const cellW = gridW / config.cols;
      const cellH = gridH / config.rows;

      // Utiliser widthPct/heightPct pour les dimensions
      const pW = cellW * (config.widthPct / 100);
      const pH = cellH * (config.heightPct / 100);

      // Zone de texte (nom)
      const nameX = cellW * (config.nameOffsetX / 100);
      const nameW = cellW * (config.nameWidth / 100);
      const nameY = cellH * (config.nameOffsetY / 100);
      const nameH = cellH * (config.nameHeight / 100);

      // Dessiner le contour de la zone de grille (vert)
      ctx.strokeStyle = '#51cf66';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(gridStartX, gridStartY, gridW, gridH);
      ctx.setLineDash([]);

      // Ecart entre lignes (rowGap en % de cellH)
      const rowGapPx = cellH * (config.rowGap / 100);

      for (let row = 0; row < config.rows; row++) {
        for (let col = 0; col < config.cols; col++) {
          const cellX = gridStartX + col * cellW;
          // Ajouter le gap cumule pour chaque ligne
          const cellY = gridStartY + row * cellH + row * rowGapPx;

          // offsetX: 50% = centre, offsetY: 0% = haut
          const x = cellX + (config.offsetX / 100) * cellW - pW / 2;
          const y = cellY + (config.offsetY / 100) * cellH;

          // Rectangle portrait (cyan)
          ctx.strokeStyle = '#00d4ff';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, pW, pH);

          // Rectangle zone texte (jaune)
          ctx.strokeStyle = '#ffd43b';
          ctx.lineWidth = 1;
          ctx.strokeRect(cellX + nameX, cellY + nameY, nameW, nameH);
        }
      }
    }

    // ===== Detection auto =====

    document.getElementById('btn-detect').addEventListener('click', detectPortraits);

    async function detectPortraits() {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }

      setStatus('Detection en cours...', 'info');
      extractedPortraits = [];

      // Zone de grille (avec marges)
      const gridStartX = loadedImage.width * (config.startX / 100);
      const gridStartY = loadedImage.height * (config.startY / 100);
      const gridW = loadedImage.width * (config.gridWidth / 100);
      const gridH = loadedImage.height * (config.gridHeight / 100);

      const cellW = gridW / config.cols;
      const cellH = gridH / config.rows;

      // Utiliser widthPct/heightPct pour les dimensions
      const pW = Math.floor(cellW * (config.widthPct / 100));
      const pH = Math.floor(cellH * (config.heightPct / 100));

      // Ecart entre lignes
      const rowGapPx = cellH * (config.rowGap / 100);

      for (let row = 0; row < config.rows; row++) {
        for (let col = 0; col < config.cols; col++) {
          const cellX = gridStartX + col * cellW;
          const cellY = gridStartY + row * cellH + row * rowGapPx;

          // offsetX: 50% = centre, offsetY: 0% = haut
          const x = Math.floor(cellX + (config.offsetX / 100) * cellW - pW / 2);
          const y = Math.floor(cellY + (config.offsetY / 100) * cellH);

          // Extraire le portrait
          const portraitCanvas = document.createElement('canvas');
          portraitCanvas.width = pW;
          portraitCanvas.height = pH;
          const pCtx = portraitCanvas.getContext('2d');
          pCtx.drawImage(previewCanvas, x, y, pW, pH, 0, 0, pW, pH);

          // Verifier si l'image est vide (moyenne de luminosite)
          const imageData = pCtx.getImageData(0, 0, pW, pH);
          const brightness = getAverageBrightness(imageData);

          const dataUrl = portraitCanvas.toDataURL('image/png');
          const hash = await computePHash(portraitCanvas);

          extractedPortraits.push({
            index: row * config.cols + col,
            row,
            col,
            x, y, w: pW, h: pH,
            dataUrl,
            hash,
            name: '',
            isEmpty: brightness < 20 // Seuil pour images vides
          });
        }
      }

      renderGrid();
      updateStats();
      setStatus(`${extractedPortraits.length} portraits detectes. Cliquez "OCR Noms" pour extraire les noms automatiquement.`, 'success');
    }

    // ===== OCR des noms =====

    document.getElementById('btn-ocr-names').addEventListener('click', ocrAllNames);

    async function ocrAllNames() {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }

      if (extractedPortraits.length === 0) {
        setStatus('Detecter les portraits d\'abord', 'error');
        return;
      }

      setStatus('Initialisation OCR...', 'info');

      try {
        // Initialiser le worker Tesseract
        if (!ocrWorker) {
          ocrWorker = await Tesseract.createWorker('fra+eng', 1, {
            logger: m => {
              if (m.status === 'recognizing text') {
                const pct = Math.round(m.progress * 100);
                setStatus(`OCR en cours... ${pct}%`, 'info');
              }
            }
          });
        }

        // Zone de grille (avec marges)
        const gridStartX = loadedImage.width * (config.startX / 100);
        const gridStartY = loadedImage.height * (config.startY / 100);
        const gridW = loadedImage.width * (config.gridWidth / 100);
        const gridH = loadedImage.height * (config.gridHeight / 100);

        const cellW = gridW / config.cols;
        const cellH = gridH / config.rows;
        const nameX = cellW * (config.nameOffsetX / 100);
        const nameW = cellW * (config.nameWidth / 100);
        const nameY = cellH * (config.nameOffsetY / 100);
        const nameH = cellH * (config.nameHeight / 100);
        const rowGapPx = cellH * (config.rowGap / 100);

        let recognized = 0;
        const total = extractedPortraits.filter(p => !p.isEmpty).length;

        for (let i = 0; i < extractedPortraits.length; i++) {
          const p = extractedPortraits[i];
          if (p.isEmpty) continue;

          setStatus(`OCR ${recognized + 1}/${total}...`, 'info');

          // Calculer la zone de texte pour ce portrait
          const cellX = gridStartX + p.col * cellW;
          const cellY = gridStartY + p.row * cellH + p.row * rowGapPx;
          const textX = Math.floor(cellX + nameX);
          const textY = Math.floor(cellY + nameY);
          const textW = Math.floor(nameW);
          const textH = Math.floor(nameH);

          // Extraire la zone de texte avec agrandissement 3x pour meilleur OCR
          const scale = 3;
          const textCanvas = document.createElement('canvas');
          textCanvas.width = textW * scale;
          textCanvas.height = textH * scale;
          const tCtx = textCanvas.getContext('2d');

          // Desactiver le lissage pour un texte plus net
          tCtx.imageSmoothingEnabled = true;
          tCtx.imageSmoothingQuality = 'high';

          // Dessiner avec agrandissement
          tCtx.drawImage(previewCanvas, textX, textY, textW, textH, 0, 0, textW * scale, textH * scale);

          // Preprocesser pour OCR (seuil adaptatif Otsu, inversion si fond sombre)
          preprocessForOCR(tCtx, textW * scale, textH * scale);

          // OCR
          const { data: { text } } = await ocrWorker.recognize(textCanvas);
          const cleanName = cleanOCRText(text);

          if (cleanName) {
            // Essayer de matcher avec la base de noms connus
            const match = findBestMatch(cleanName);

            if (match) {
              extractedPortraits[i].name = match.name;
              extractedPortraits[i].charId = match.charId;
              extractedPortraits[i].matchConfidence = match.similarity;
              extractedPortraits[i].ocrRaw = text.trim();
              extractedPortraits[i].ocrClean = cleanName;
            } else {
              // Aucun match trouve, garder le texte OCR nettoye
              extractedPortraits[i].name = cleanName;
              extractedPortraits[i].ocrRaw = text.trim();
              extractedPortraits[i].matchConfidence = 0;
            }
            recognized++;
          }
        }

        const matched = extractedPortraits.filter(p => p.matchConfidence && p.matchConfidence >= 60).length;
        renderGrid();
        updateStats();
        setStatus(`OCR termine: ${recognized} noms reconnus, ${matched} matches dans la base (${knownNames.length} noms connus)`, 'success');

      } catch (e) {
        console.error('Erreur OCR:', e);
        setStatus('Erreur OCR: ' + e.message, 'error');
      }
    }

    function preprocessForOCR(ctx, w, h) {
      // MSF utilise du texte dore/blanc sur fond sombre
      // On va: 1) agrandir 3x, 2) detecter le texte clair, 3) binariser avec seuil adaptatif

      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;

      // Analyser l'histogramme pour trouver le seuil optimal
      const histogram = new Array(256).fill(0);
      const brightnesses = [];

      for (let i = 0; i < data.length; i += 4) {
        // Utiliser une formule qui favorise le jaune/or (caracteristique MSF)
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        // Le texte MSF est souvent jaune/or (R et G eleves, B plus bas)
        const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
        histogram[gray]++;
        brightnesses.push(gray);
      }

      // Trouver la luminosite moyenne
      const avgBrightness = brightnesses.reduce((a, b) => a + b, 0) / brightnesses.length;

      // Methode d'Otsu pour trouver le seuil optimal
      const total = brightnesses.length;
      let sum = 0;
      for (let i = 0; i < 256; i++) sum += i * histogram[i];

      let sumB = 0;
      let wB = 0;
      let maxVariance = 0;
      let threshold = 128;

      for (let t = 0; t < 256; t++) {
        wB += histogram[t];
        if (wB === 0) continue;
        const wF = total - wB;
        if (wF === 0) break;

        sumB += t * histogram[t];
        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;
        const variance = wB * wF * (mB - mF) * (mB - mF);

        if (variance > maxVariance) {
          maxVariance = variance;
          threshold = t;
        }
      }

      // Ajuster le seuil pour MSF (texte clair sur fond sombre)
      // Si la moyenne est sombre, baisser le seuil pour capturer plus de texte clair
      if (avgBrightness < 80) {
        threshold = Math.max(60, threshold - 30);
      }

      // Appliquer le preprocessing: inversion + binarisation
      const invert = avgBrightness < 100;

      for (let i = 0; i < data.length; i += 4) {
        let gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];

        // Pour MSF, le texte est clair (valeur haute) - on veut le garder
        if (invert) {
          // Fond sombre: les pixels clairs (texte) deviennent noirs apres inversion
          gray = 255 - gray;
        }

        // Binarisation avec le seuil d'Otsu
        gray = gray < threshold ? 0 : 255;

        data[i] = gray;
        data[i + 1] = gray;
        data[i + 2] = gray;
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function cleanOCRText(text) {
      if (!text) return '';

      // Nettoyer le texte OCR
      let clean = text.trim()
        .replace(/\n/g, ' ')           // Remplacer sauts de ligne
        .replace(/\s+/g, ' ')          // Normaliser espaces
        .replace(/[_|\\\/\[\]{}«»""]/g, '') // Supprimer caracteres parasites
        .replace(/\s*[.,;:!?]+\s*$/g, '') // Supprimer ponctuation finale
        .trim();

      // Corrections OCR courantes pour MSF
      clean = clean
        .replace(/\bME\s*U\b/gi, 'MCU')           // ME U -> MCU
        .replace(/\b0\b/g, 'O')                    // 0 -> O (zero vs lettre)
        .replace(/\b1\b/g, 'I')                    // 1 -> I
        .replace(/\bll\b/gi, 'II')                 // ll -> II (chiffre romain)
        .replace(/\bFEND[GC]J\b/gi, 'ENDGAME')    // FENDGJ -> ENDGAME
        .replace(/\bTHAND[S]?\b/gi, 'THANOS')     // THANDS -> THANOS
        .replace(/\bTOMERE\b/gi, "D'OMBRE")       // TOMERE -> D'OMBRE
        .replace(/\bFANTASII\b/gi, 'FANTASTIC')   // FANTASII -> FANTASTIC
        .replace(/\bRO[1I]\b/gi, 'ROI')           // RO1 ou ROI corrige
        .replace(/\bINVIS[1I]BLE\b/gi, 'INVISIBLE')
        .replace(/\b([A-Z])\s+([A-Z])\b/g, '$1$2') // Lettres separees par espace
        .replace(/\(\s+/g, '(')                    // Espace apres (
        .replace(/\s+\)/g, ')')                    // Espace avant )
        .trim();

      // Supprimer prefixe/suffixe non-alpha (apres corrections)
      clean = clean
        .replace(/^[^a-zA-Z(]+/, '')
        .replace(/[^a-zA-Z)]+$/, '')
        .trim();

      // Ignorer les resultats trop courts ou avec trop peu de lettres
      const letters = clean.replace(/[^a-zA-Z]/g, '');
      if (letters.length < 3) return '';

      // Mettre en majuscules (comme dans le jeu)
      return clean.toUpperCase();
    }

    function getAverageBrightness(imageData) {
      const data = imageData.data;
      let sum = 0;
      for (let i = 0; i < data.length; i += 4) {
        sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
      }
      return sum / (data.length / 4);
    }

    // ===== Mode manuel =====

    document.getElementById('btn-manual').addEventListener('click', () => {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }
      isManualMode = true;
      manualMode.classList.add('visible');
      configPanel.classList.remove('visible');
      setStatus('Cliquez sur un portrait pour l\'extraire', 'info');
    });

    document.getElementById('btn-exit-manual').addEventListener('click', () => {
      isManualMode = false;
      manualMode.classList.remove('visible');
      const ctx = selectionCanvas.getContext('2d');
      ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
    });

    selectionCanvas.addEventListener('click', (e) => {
      if (!isManualMode || !loadedImage) return;

      const rect = selectionCanvas.getBoundingClientRect();
      const scaleX = loadedImage.width / rect.width;
      const scaleY = loadedImage.height / rect.height;

      const clickX = (e.clientX - rect.left) * scaleX;
      const clickY = (e.clientY - rect.top) * scaleY;

      const size = parseInt(document.getElementById('manual-size').value) || 64;
      const x = Math.floor(clickX - size / 2);
      const y = Math.floor(clickY - size / 2);

      extractManualPortrait(x, y, size);
    });

    async function extractManualPortrait(x, y, size) {
      // Limiter aux bords
      x = Math.max(0, Math.min(x, loadedImage.width - size));
      y = Math.max(0, Math.min(y, loadedImage.height - size));

      // Dessiner le rectangle de selection
      const ctx = selectionCanvas.getContext('2d');
      ctx.strokeStyle = '#51cf66';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, size, size);

      // Extraire
      const portraitCanvas = document.createElement('canvas');
      portraitCanvas.width = size;
      portraitCanvas.height = size;
      const pCtx = portraitCanvas.getContext('2d');
      pCtx.drawImage(previewCanvas, x, y, size, size, 0, 0, size, size);

      const dataUrl = portraitCanvas.toDataURL('image/png');
      const hash = await computePHash(portraitCanvas);

      // Demander le nom
      const name = prompt('Nom du personnage:');

      if (name && name.trim()) {
        extractedPortraits.push({
          index: extractedPortraits.length,
          x, y, w: size, h: size,
          dataUrl,
          hash,
          name: name.trim(),
          isEmpty: false,
          manual: true
        });

        renderGrid();
        updateStats();
        setStatus(`Portrait "${name.trim()}" ajoute`, 'success');
      }
    }

    // ===== Rendu =====

    function renderGrid() {
      grid.innerHTML = '';

      extractedPortraits.forEach((p, i) => {
        const card = document.createElement('div');
        card.className = 'portrait-card' + (p.isEmpty ? ' empty' : '');

        // Indicateur de confiance du match
        let matchIndicator = '';
        if (p.matchConfidence !== undefined) {
          if (p.matchConfidence >= 90) {
            matchIndicator = `<div class="match-badge match-high" title="Match exact">✓ ${p.matchConfidence}%</div>`;
          } else if (p.matchConfidence >= 70) {
            matchIndicator = `<div class="match-badge match-medium" title="Bon match">~ ${p.matchConfidence}%</div>`;
          } else if (p.matchConfidence >= 60) {
            matchIndicator = `<div class="match-badge match-low" title="Match incertain">? ${p.matchConfidence}%</div>`;
          } else if (p.matchConfidence === 0 && p.ocrRaw) {
            matchIndicator = `<div class="match-badge match-none" title="Aucun match dans la base">✗</div>`;
          }
        }

        // Afficher le texte OCR brut si different du resultat final
        const ocrHint = p.ocrClean && p.ocrClean !== p.name
          ? `<div class="ocr-raw" title="OCR detecte: ${p.ocrRaw}">${p.ocrClean}</div>`
          : (p.ocrRaw && p.ocrRaw !== p.name ? `<div class="ocr-raw" title="OCR brut">${p.ocrRaw}</div>` : '');

        card.innerHTML = `
          <div class="index">#${p.index}</div>
          ${matchIndicator}
          <img src="${p.dataUrl}" alt="Portrait ${i}" data-index="${i}">
          <input type="text" value="${p.name}" placeholder="Nom..." data-index="${i}">
          ${ocrHint}
          <div class="hash">${p.hash.substring(0, 8)}...</div>
        `;

        card.querySelector('input').addEventListener('change', (e) => {
          extractedPortraits[i].name = e.target.value.trim();
          updateStats();
        });

        card.querySelector('img').addEventListener('click', () => {
          // Highlight dans la preview
          if (p.x !== undefined) {
            const ctx = selectionCanvas.getContext('2d');
            ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            ctx.strokeStyle = '#ffd43b';
            ctx.lineWidth = 3;
            ctx.strokeRect(p.x, p.y, p.w, p.h);
          }
        });

        grid.appendChild(card);
      });

      stats.classList.add('visible');
    }

    function updateStats() {
      const total = extractedPortraits.filter(p => !p.isEmpty).length;
      const named = extractedPortraits.filter(p => p.name && !p.isEmpty).length;
      countSpan.textContent = total;
      namedCountSpan.textContent = named;
    }

    // ===== pHash =====

    async function computePHash(canvas) {
      const hashSize = 8;
      const sampleSize = 32;

      const smallCanvas = document.createElement('canvas');
      smallCanvas.width = sampleSize;
      smallCanvas.height = sampleSize;
      const ctx = smallCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, 0, sampleSize, sampleSize);

      const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);
      const pixels = imageData.data;

      const gray = new Float32Array(sampleSize * sampleSize);
      for (let i = 0; i < gray.length; i++) {
        const offset = i * 4;
        gray[i] = 0.299 * pixels[offset] + 0.587 * pixels[offset + 1] + 0.114 * pixels[offset + 2];
      }

      const reduced = new Float32Array(hashSize * hashSize);
      const blockSize = sampleSize / hashSize;

      for (let y = 0; y < hashSize; y++) {
        for (let x = 0; x < hashSize; x++) {
          let sum = 0;
          let count = 0;
          const startY = Math.floor(y * blockSize);
          const endY = Math.floor((y + 1) * blockSize);
          const startX = Math.floor(x * blockSize);
          const endX = Math.floor((x + 1) * blockSize);

          for (let py = startY; py < endY; py++) {
            for (let px = startX; px < endX; px++) {
              sum += gray[py * sampleSize + px];
              count++;
            }
          }
          reduced[y * hashSize + x] = count > 0 ? sum / count : 0;
        }
      }

      const sorted = [...reduced].sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];

      let binary = '';
      for (let i = 0; i < reduced.length; i++) {
        binary += reduced[i] > median ? '1' : '0';
      }

      let hex = '';
      for (let i = 0; i < binary.length; i += 4) {
        hex += parseInt(binary.substr(i, 4), 2).toString(16);
      }

      return hex;
    }

    // ===== Export =====

    document.getElementById('btn-export').addEventListener('click', exportJSON);
    document.getElementById('btn-copy').addEventListener('click', copyToClipboard);
    document.getElementById('btn-clear').addEventListener('click', clearAll);

    function generateJSON() {
      const portraits = {};
      const portraitsDetailed = {};

      extractedPortraits.forEach(p => {
        if (p.name && p.name.trim() && !p.isEmpty) {
          portraits[p.hash] = p.name.trim();

          // Version detaillee avec charId si disponible
          portraitsDetailed[p.hash] = {
            name: p.name.trim(),
            charId: p.charId || null,
            matchConfidence: p.matchConfidence || null
          };
        }
      });

      return JSON.stringify({
        description: "Portraits MSF - genere par portrait-extractor",
        generatedAt: new Date().toISOString(),
        count: Object.keys(portraits).length,
        portraits,             // Format simple hash -> nom (compatible avec l'extension)
        portraitsDetailed      // Format detaille avec charId
      }, null, 2);
    }

    function exportJSON() {
      const json = generateJSON();

      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `msf-portraits-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      output.textContent = json;
      output.style.display = 'block';

      const count = extractedPortraits.filter(p => p.name && !p.isEmpty).length;
      setStatus(`Exporte ${count} portraits`, 'success');
    }

    function copyToClipboard() {
      const json = generateJSON();
      navigator.clipboard.writeText(json).then(() => {
        setStatus('JSON copie', 'success');
      });
    }

    function clearAll() {
      extractedPortraits = [];
      grid.innerHTML = '';
      output.style.display = 'none';
      stats.classList.remove('visible');

      const ctx = selectionCanvas.getContext('2d');
      ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

      const gctx = gridOverlay.getContext('2d');
      gctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);

      setStatus('Liste effacee', 'info');
    }

    function setStatus(msg, type) {
      status.textContent = msg;
      status.className = type;
    }
  </script>
</body>
</html>
