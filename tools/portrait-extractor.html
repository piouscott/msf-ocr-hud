<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>MSF Portrait Extractor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 20px;
    }
    h1 { color: #00d4ff; margin-bottom: 20px; }

    .instructions {
      background: #2d2d44;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .instructions h2 { font-size: 14px; margin-bottom: 10px; color: #00d4ff; }
    .instructions ol { margin-left: 20px; font-size: 13px; line-height: 1.8; }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    .btn-primary { background: #00d4ff; color: #1a1a2e; }
    .btn-success { background: #51cf66; color: #1a1a2e; }
    .btn-secondary { background: #2d2d44; color: #ccc; border: 1px solid #444; }
    .btn-warning { background: #ffd43b; color: #1a1a2e; }

    #drop-zone {
      border: 2px dashed #444;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 20px;
      transition: border-color 0.2s;
    }
    #drop-zone.dragover { border-color: #00d4ff; }
    #drop-zone p { color: #888; }

    .preview-container {
      position: relative;
      margin-bottom: 20px;
      overflow: auto;
      max-height: 500px;
      border: 1px solid #444;
      border-radius: 8px;
    }

    #preview {
      display: block;
    }

    #grid-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    #status {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 20px;
      display: none;
    }
    #status.success { display: block; background: #51cf66; color: #1a1a2e; }
    #status.error { display: block; background: #ff6b6b; color: #fff; }
    #status.info { display: block; background: #00d4ff; color: #1a1a2e; }

    /* Config panel */
    .config-panel {
      background: #2d2d44;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .config-panel.visible { display: block; }

    .config-row {
      display: flex;
      gap: 20px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .config-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .config-item label {
      font-size: 12px;
      color: #888;
      min-width: 80px;
    }

    .config-item input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a2e;
      color: #fff;
      font-size: 12px;
    }

    .config-item input[type="range"] {
      width: 120px;
    }

    .config-item span {
      font-size: 11px;
      color: #00d4ff;
      min-width: 30px;
    }

    #portraits-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
      margin-bottom: 20px;
    }

    .portrait-card {
      background: #2d2d44;
      border-radius: 8px;
      padding: 8px;
      text-align: center;
    }

    .portrait-card.empty {
      opacity: 0.3;
    }

    .portrait-card img {
      width: 64px;
      height: 64px;
      border-radius: 4px;
      margin-bottom: 6px;
      border: 2px solid transparent;
    }

    .portrait-card.selected img {
      border-color: #00d4ff;
    }

    .portrait-card input {
      width: 100%;
      padding: 3px 6px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a2e;
      color: #fff;
      font-size: 10px;
      text-align: center;
    }

    .portrait-card .hash {
      font-size: 8px;
      color: #555;
      margin-top: 3px;
      word-break: break-all;
    }

    .portrait-card .ocr-raw {
      font-size: 8px;
      color: #ffd43b;
      margin-top: 2px;
      word-break: break-all;
      opacity: 0.7;
    }

    .portrait-card .index {
      font-size: 9px;
      color: #666;
      margin-bottom: 4px;
    }

    #output {
      background: #0d0d1a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      max-height: 300px;
      overflow: auto;
      white-space: pre-wrap;
      display: none;
    }

    .stats {
      background: #2d2d44;
      padding: 10px 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-size: 13px;
      display: none;
    }

    .stats.visible { display: block; }

    /* Mode selection manuelle */
    .manual-mode {
      background: #3d2d44;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .manual-mode.visible { display: block; }

    .manual-mode h3 {
      color: #ffd43b;
      margin-bottom: 10px;
      font-size: 14px;
    }

    .manual-mode p {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 10px;
    }

    #canvas-container {
      position: relative;
      display: inline-block;
      cursor: crosshair;
    }

    #selection-canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <!-- Tesseract.js pour OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <h1>MSF Portrait Extractor</h1>

  <div class="instructions">
    <h2>Mode d'emploi</h2>
    <ol>
      <li>Charger une capture d'ecran de la page des personnages MSF</li>
      <li><b>Mode Auto</b>: Ajuster les parametres de grille puis "Detecter"</li>
      <li><b>Mode Manuel</b>: Cliquer sur chaque portrait pour l'extraire</li>
      <li>Remplir les noms des personnages</li>
      <li>Exporter en JSON</li>
    </ol>
  </div>

  <div class="controls">
    <button class="btn-primary" id="btn-load">Charger image</button>
    <button class="btn-secondary" id="btn-toggle-config">Config grille</button>
    <button class="btn-warning" id="btn-auto-params">Auto-params</button>
    <button class="btn-secondary" id="btn-detect">Detecter portraits</button>
    <button class="btn-primary" id="btn-ocr-names">OCR Noms</button>
    <button class="btn-warning" id="btn-manual">Mode manuel</button>
    <button class="btn-success" id="btn-export">Exporter JSON</button>
    <button class="btn-secondary" id="btn-copy">Copier</button>
    <button class="btn-secondary" id="btn-clear">Effacer tout</button>
  </div>

  <input type="file" id="file-input" accept="image/*" style="display:none">

  <div id="drop-zone">
    <p>Glisser-deposer une image ici<br>ou cliquer sur "Charger image"</p>
  </div>

  <div class="config-panel" id="config-panel">
    <div style="font-size:12px; color:#51cf66; margin-bottom:8px;">Zone de la grille (marges):</div>
    <div class="config-row">
      <div class="config-item">
        <label>Colonnes:</label>
        <input type="number" id="cfg-cols" value="12" min="1" max="20">
      </div>
      <div class="config-item">
        <label>Lignes:</label>
        <input type="number" id="cfg-rows" value="5" min="1" max="20">
      </div>
    </div>
    <div class="config-row">
      <div class="config-item">
        <label>Marge gauche:</label>
        <input type="range" id="cfg-startX" value="0" min="0" max="30">
        <span id="cfg-startX-val">0%</span>
      </div>
      <div class="config-item">
        <label>Marge haute:</label>
        <input type="range" id="cfg-startY" value="0" min="0" max="30">
        <span id="cfg-startY-val">0%</span>
      </div>
    </div>
    <div class="config-row">
      <div class="config-item">
        <label>Largeur grille:</label>
        <input type="range" id="cfg-gridWidth" value="100" min="70" max="100">
        <span id="cfg-gridWidth-val">100%</span>
      </div>
      <div class="config-item">
        <label>Hauteur grille:</label>
        <input type="range" id="cfg-gridHeight" value="100" min="70" max="100">
        <span id="cfg-gridHeight-val">100%</span>
      </div>
    </div>
    <div class="config-row">
      <div class="config-item">
        <label>Ecart lignes:</label>
        <input type="range" id="cfg-rowGap" value="0" min="-10" max="20">
        <span id="cfg-rowGap-val">0%</span>
      </div>
    </div>

    <div style="margin-top:15px; padding-top:15px; border-top:1px solid #444;">
      <div style="font-size:12px; color:#00d4ff; margin-bottom:8px;">Position portrait dans la cellule:</div>
      <div class="config-row">
        <div class="config-item">
          <label>Offset X:</label>
          <input type="range" id="cfg-offsetX" value="50" min="0" max="100">
          <span id="cfg-offsetX-val">50%</span>
        </div>
        <div class="config-item">
          <label>Offset Y:</label>
          <input type="range" id="cfg-offsetY" value="8" min="0" max="100">
          <span id="cfg-offsetY-val">8%</span>
        </div>
      </div>
      <div class="config-row">
        <div class="config-item">
          <label>Largeur %:</label>
          <input type="range" id="cfg-widthPct" value="75" min="20" max="100">
          <span id="cfg-widthPct-val">75%</span>
        </div>
        <div class="config-item">
          <label>Hauteur %:</label>
          <input type="range" id="cfg-heightPct" value="55" min="20" max="100">
          <span id="cfg-heightPct-val">55%</span>
        </div>
      </div>
    </div>
    <button class="btn-secondary" id="btn-preview-grid" style="margin-top:10px">Previsualiser grille</button>

    <div style="margin-top:15px; padding-top:15px; border-top:1px solid #444;">
      <div style="font-size:12px; color:#ffd43b; margin-bottom:8px;">Zone texte (nom du personnage):</div>
      <div class="config-row">
        <div class="config-item">
          <label>Offset Y nom:</label>
          <input type="range" id="cfg-nameOffsetY" value="82" min="50" max="100">
          <span id="cfg-nameOffsetY-val">82%</span>
        </div>
        <div class="config-item">
          <label>Hauteur nom:</label>
          <input type="range" id="cfg-nameHeight" value="10" min="5" max="25">
          <span id="cfg-nameHeight-val">10%</span>
        </div>
      </div>
    </div>
  </div>

  <div class="manual-mode" id="manual-mode">
    <h3>Mode selection manuelle</h3>
    <p>Cliquez sur l'image pour selectionner un portrait (carre 64x64). Entrez le nom puis cliquez sur le suivant.</p>
    <div class="config-item" style="margin-bottom:10px">
      <label>Taille selection:</label>
      <input type="number" id="manual-size" value="64" min="32" max="128" style="width:60px">
      <span>px</span>
    </div>
    <button class="btn-secondary" id="btn-exit-manual">Quitter mode manuel</button>
  </div>

  <div class="preview-container" id="preview-container" style="display:none">
    <div id="canvas-container">
      <canvas id="preview"></canvas>
      <canvas id="grid-overlay"></canvas>
      <canvas id="selection-canvas"></canvas>
    </div>
  </div>

  <div id="status"></div>

  <div class="stats" id="stats">
    Portraits: <span id="count">0</span> | Nommes: <span id="named-count">0</span>
  </div>

  <div id="portraits-grid"></div>

  <div id="output"></div>

  <script>
    let loadedImage = null;
    let extractedPortraits = [];
    let isManualMode = false;

    // Config - valeurs optimisees pour les cartes MSF
    // Structure carte MSF: portrait carre en haut (~55% de la cellule), nom en bas
    const config = {
      cols: 12,
      rows: 5,
      startX: 0,        // % marge gauche avant la grille
      startY: 0,        // % marge haute avant la grille
      gridWidth: 100,   // % largeur totale de la grille (100 = toute l'image)
      gridHeight: 100,  // % hauteur totale de la grille
      rowGap: 0,        // % espacement supplementaire entre les lignes
      portraitSize: 80, // % (legacy, non utilise si widthPct/heightPct definis)
      offsetX: 50,      // % position horizontale du centre dans la cellule
      offsetY: 8,       // % position verticale du haut dans la cellule (petit decalage)
      widthPct: 75,     // % largeur du portrait par rapport a la cellule
      heightPct: 55,    // % hauteur du portrait par rapport a la cellule (carre visuellement)
      nameOffsetY: 82,  // % position Y du texte du nom dans la cellule
      nameHeight: 10    // % hauteur de la zone de texte
    };

    // OCR worker
    let ocrWorker = null;

    // Elements DOM
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const previewContainer = document.getElementById('preview-container');
    const previewCanvas = document.getElementById('preview');
    const gridOverlay = document.getElementById('grid-overlay');
    const selectionCanvas = document.getElementById('selection-canvas');
    const status = document.getElementById('status');
    const stats = document.getElementById('stats');
    const countSpan = document.getElementById('count');
    const namedCountSpan = document.getElementById('named-count');
    const grid = document.getElementById('portraits-grid');
    const output = document.getElementById('output');
    const configPanel = document.getElementById('config-panel');
    const manualMode = document.getElementById('manual-mode');

    // ===== Gestion des fichiers =====

    document.getElementById('btn-load').addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', (e) => {
      if (e.target.files[0]) loadImage(e.target.files[0]);
    });

    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });

    dropZone.addEventListener('dragleave', () => {
      dropZone.classList.remove('dragover');
    });

    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
    });

    function loadImage(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          loadedImage = img;

          // Dessiner sur le canvas
          previewCanvas.width = img.width;
          previewCanvas.height = img.height;
          gridOverlay.width = img.width;
          gridOverlay.height = img.height;
          selectionCanvas.width = img.width;
          selectionCanvas.height = img.height;

          const ctx = previewCanvas.getContext('2d');
          ctx.drawImage(img, 0, 0);

          previewContainer.style.display = 'block';
          dropZone.style.display = 'none';

          setStatus(`Image: ${img.width}x${img.height}`, 'success');
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // ===== Config =====

    document.getElementById('btn-toggle-config').addEventListener('click', () => {
      configPanel.classList.toggle('visible');
    });

    // Config inputs
    document.getElementById('cfg-cols').addEventListener('change', (e) => {
      config.cols = parseInt(e.target.value) || 12;
    });
    document.getElementById('cfg-rows').addEventListener('change', (e) => {
      config.rows = parseInt(e.target.value) || 5;
    });

    // Marges de grille
    document.getElementById('cfg-startX').addEventListener('input', (e) => {
      config.startX = parseInt(e.target.value);
      document.getElementById('cfg-startX-val').textContent = config.startX + '%';
    });
    document.getElementById('cfg-startY').addEventListener('input', (e) => {
      config.startY = parseInt(e.target.value);
      document.getElementById('cfg-startY-val').textContent = config.startY + '%';
    });
    document.getElementById('cfg-gridWidth').addEventListener('input', (e) => {
      config.gridWidth = parseInt(e.target.value);
      document.getElementById('cfg-gridWidth-val').textContent = config.gridWidth + '%';
    });
    document.getElementById('cfg-gridHeight').addEventListener('input', (e) => {
      config.gridHeight = parseInt(e.target.value);
      document.getElementById('cfg-gridHeight-val').textContent = config.gridHeight + '%';
    });
    document.getElementById('cfg-rowGap').addEventListener('input', (e) => {
      config.rowGap = parseInt(e.target.value);
      document.getElementById('cfg-rowGap-val').textContent = config.rowGap + '%';
    });

    // Position portrait dans cellule
    document.getElementById('cfg-offsetX').addEventListener('input', (e) => {
      config.offsetX = parseInt(e.target.value);
      document.getElementById('cfg-offsetX-val').textContent = config.offsetX + '%';
    });
    document.getElementById('cfg-offsetY').addEventListener('input', (e) => {
      config.offsetY = parseInt(e.target.value);
      document.getElementById('cfg-offsetY-val').textContent = config.offsetY + '%';
    });
    document.getElementById('cfg-widthPct').addEventListener('input', (e) => {
      config.widthPct = parseInt(e.target.value);
      document.getElementById('cfg-widthPct-val').textContent = config.widthPct + '%';
    });
    document.getElementById('cfg-heightPct').addEventListener('input', (e) => {
      config.heightPct = parseInt(e.target.value);
      document.getElementById('cfg-heightPct-val').textContent = config.heightPct + '%';
    });
    document.getElementById('cfg-nameOffsetY').addEventListener('input', (e) => {
      config.nameOffsetY = parseInt(e.target.value);
      document.getElementById('cfg-nameOffsetY-val').textContent = config.nameOffsetY + '%';
    });
    document.getElementById('cfg-nameHeight').addEventListener('input', (e) => {
      config.nameHeight = parseInt(e.target.value);
      document.getElementById('cfg-nameHeight-val').textContent = config.nameHeight + '%';
    });

    document.getElementById('btn-preview-grid').addEventListener('click', previewGrid);

    // ===== Auto-detection des parametres =====
    document.getElementById('btn-auto-params').addEventListener('click', autoDetectParams);

    async function autoDetectParams() {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }

      setStatus('Analyse de l\'image...', 'info');

      try {
        // Analyser l'image pour detecter la structure des cartes
        const ctx = previewCanvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, loadedImage.width, loadedImage.height);

        // Detecter les bordures verticales (lignes sombres entre les cartes)
        const verticalEdges = detectVerticalEdges(imageData, loadedImage.width, loadedImage.height);

        // Detecter les bordures horizontales
        const horizontalEdges = detectHorizontalEdges(imageData, loadedImage.width, loadedImage.height);

        // Estimer le nombre de colonnes et lignes
        const estimatedCols = Math.max(1, verticalEdges.length - 1) || config.cols;
        const estimatedRows = Math.max(1, horizontalEdges.length - 1) || config.rows;

        // Si detection reussie, mettre a jour la config
        if (verticalEdges.length > 1 && horizontalEdges.length > 1) {
          config.cols = estimatedCols;
          config.rows = estimatedRows;
          document.getElementById('cfg-cols').value = config.cols;
          document.getElementById('cfg-rows').value = config.rows;

          setStatus(`Detecte: ${config.cols} colonnes x ${config.rows} lignes. Ajustez les autres parametres si besoin.`, 'success');
        } else {
          // Utiliser des valeurs par defaut optimisees pour MSF
          setStatus('Auto-detection partielle. Parametres MSF optimises appliques.', 'info');
        }

        // Appliquer les parametres optimises pour MSF et afficher la grille
        applyMSFDefaults();
        configPanel.classList.add('visible');
        previewGrid();

      } catch (e) {
        console.error('Erreur auto-detection:', e);
        setStatus('Erreur analyse. Parametres MSF par defaut appliques.', 'error');
        applyMSFDefaults();
        previewGrid();
      }
    }

    function applyMSFDefaults() {
      // Appliquer les valeurs optimisees pour MSF
      // Marges de grille (l'image MSF a un peu de marge)
      config.startX = 1;
      config.startY = 0;
      config.gridWidth = 98;
      config.gridHeight = 100;
      config.rowGap = 0;

      // Position portrait dans cellule
      config.offsetX = 50;
      config.offsetY = 5;
      config.widthPct = 70;
      config.heightPct = 50;
      config.nameOffsetY = 80;
      config.nameHeight = 10;

      // Mettre a jour les sliders - marges
      document.getElementById('cfg-startX').value = config.startX;
      document.getElementById('cfg-startX-val').textContent = config.startX + '%';
      document.getElementById('cfg-startY').value = config.startY;
      document.getElementById('cfg-startY-val').textContent = config.startY + '%';
      document.getElementById('cfg-gridWidth').value = config.gridWidth;
      document.getElementById('cfg-gridWidth-val').textContent = config.gridWidth + '%';
      document.getElementById('cfg-gridHeight').value = config.gridHeight;
      document.getElementById('cfg-gridHeight-val').textContent = config.gridHeight + '%';
      document.getElementById('cfg-rowGap').value = config.rowGap;
      document.getElementById('cfg-rowGap-val').textContent = config.rowGap + '%';

      // Mettre a jour les sliders - portrait
      document.getElementById('cfg-offsetX').value = config.offsetX;
      document.getElementById('cfg-offsetX-val').textContent = config.offsetX + '%';
      document.getElementById('cfg-offsetY').value = config.offsetY;
      document.getElementById('cfg-offsetY-val').textContent = config.offsetY + '%';
      document.getElementById('cfg-widthPct').value = config.widthPct;
      document.getElementById('cfg-widthPct-val').textContent = config.widthPct + '%';
      document.getElementById('cfg-heightPct').value = config.heightPct;
      document.getElementById('cfg-heightPct-val').textContent = config.heightPct + '%';
      document.getElementById('cfg-nameOffsetY').value = config.nameOffsetY;
      document.getElementById('cfg-nameOffsetY-val').textContent = config.nameOffsetY + '%';
      document.getElementById('cfg-nameHeight').value = config.nameHeight;
      document.getElementById('cfg-nameHeight-val').textContent = config.nameHeight + '%';
    }

    function detectVerticalEdges(imageData, width, height) {
      const edges = [];
      const data = imageData.data;
      const threshold = 30; // Difference de luminosite pour detecter un bord
      const minGap = width / 20; // Espace minimum entre deux bords

      // Scanner le tiers superieur de l'image (la ou les portraits sont)
      const scanHeight = Math.floor(height / 3);
      const startY = Math.floor(height / 6);

      for (let x = 5; x < width - 5; x++) {
        let edgeScore = 0;

        // Verifier si c'est une ligne verticale sombre
        for (let y = startY; y < startY + scanHeight; y += 5) {
          const idx = (y * width + x) * 4;
          const leftIdx = (y * width + x - 3) * 4;
          const rightIdx = (y * width + x + 3) * 4;

          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const leftBrightness = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
          const rightBrightness = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;

          // Bord detecte si la colonne est plus sombre que ses voisines
          if (brightness < 50 && (leftBrightness - brightness > threshold || rightBrightness - brightness > threshold)) {
            edgeScore++;
          }
        }

        // Si assez de points de bord detectes
        if (edgeScore > scanHeight / 20) {
          // Verifier qu'on est assez loin du dernier bord
          if (edges.length === 0 || x - edges[edges.length - 1] > minGap) {
            edges.push(x);
          }
        }
      }

      return edges;
    }

    function detectHorizontalEdges(imageData, width, height) {
      const edges = [];
      const data = imageData.data;
      const threshold = 30;
      const minGap = height / 10;

      // Scanner le centre horizontal de l'image
      const scanWidth = Math.floor(width / 3);
      const startX = Math.floor(width / 3);

      for (let y = 5; y < height - 5; y++) {
        let edgeScore = 0;

        for (let x = startX; x < startX + scanWidth; x += 5) {
          const idx = (y * width + x) * 4;
          const topIdx = ((y - 3) * width + x) * 4;
          const bottomIdx = ((y + 3) * width + x) * 4;

          const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
          const topBrightness = (data[topIdx] + data[topIdx + 1] + data[topIdx + 2]) / 3;
          const bottomBrightness = (data[bottomIdx] + data[bottomIdx + 1] + data[bottomIdx + 2]) / 3;

          if (brightness < 50 && (topBrightness - brightness > threshold || bottomBrightness - brightness > threshold)) {
            edgeScore++;
          }
        }

        if (edgeScore > scanWidth / 20) {
          if (edges.length === 0 || y - edges[edges.length - 1] > minGap) {
            edges.push(y);
          }
        }
      }

      return edges;
    }

    function previewGrid() {
      if (!loadedImage) return;

      const ctx = gridOverlay.getContext('2d');
      ctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);

      // Zone de grille (avec marges)
      const gridStartX = loadedImage.width * (config.startX / 100);
      const gridStartY = loadedImage.height * (config.startY / 100);
      const gridW = loadedImage.width * (config.gridWidth / 100);
      const gridH = loadedImage.height * (config.gridHeight / 100);

      const cellW = gridW / config.cols;
      const cellH = gridH / config.rows;

      // Utiliser widthPct/heightPct pour les dimensions
      const pW = cellW * (config.widthPct / 100);
      const pH = cellH * (config.heightPct / 100);

      // Zone de texte (nom)
      const nameY = cellH * (config.nameOffsetY / 100);
      const nameH = cellH * (config.nameHeight / 100);

      // Dessiner le contour de la zone de grille (vert)
      ctx.strokeStyle = '#51cf66';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(gridStartX, gridStartY, gridW, gridH);
      ctx.setLineDash([]);

      // Ecart entre lignes (rowGap en % de cellH)
      const rowGapPx = cellH * (config.rowGap / 100);

      for (let row = 0; row < config.rows; row++) {
        for (let col = 0; col < config.cols; col++) {
          const cellX = gridStartX + col * cellW;
          // Ajouter le gap cumule pour chaque ligne
          const cellY = gridStartY + row * cellH + row * rowGapPx;

          // offsetX: 50% = centre, offsetY: 0% = haut
          const x = cellX + (config.offsetX / 100) * cellW - pW / 2;
          const y = cellY + (config.offsetY / 100) * cellH;

          // Rectangle portrait (cyan)
          ctx.strokeStyle = '#00d4ff';
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, pW, pH);

          // Rectangle zone texte (jaune)
          ctx.strokeStyle = '#ffd43b';
          ctx.lineWidth = 1;
          ctx.strokeRect(cellX + cellW * 0.05, cellY + nameY, cellW * 0.9, nameH);
        }
      }
    }

    // ===== Detection auto =====

    document.getElementById('btn-detect').addEventListener('click', detectPortraits);

    async function detectPortraits() {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }

      setStatus('Detection en cours...', 'info');
      extractedPortraits = [];

      // Zone de grille (avec marges)
      const gridStartX = loadedImage.width * (config.startX / 100);
      const gridStartY = loadedImage.height * (config.startY / 100);
      const gridW = loadedImage.width * (config.gridWidth / 100);
      const gridH = loadedImage.height * (config.gridHeight / 100);

      const cellW = gridW / config.cols;
      const cellH = gridH / config.rows;

      // Utiliser widthPct/heightPct pour les dimensions
      const pW = Math.floor(cellW * (config.widthPct / 100));
      const pH = Math.floor(cellH * (config.heightPct / 100));

      // Ecart entre lignes
      const rowGapPx = cellH * (config.rowGap / 100);

      for (let row = 0; row < config.rows; row++) {
        for (let col = 0; col < config.cols; col++) {
          const cellX = gridStartX + col * cellW;
          const cellY = gridStartY + row * cellH + row * rowGapPx;

          // offsetX: 50% = centre, offsetY: 0% = haut
          const x = Math.floor(cellX + (config.offsetX / 100) * cellW - pW / 2);
          const y = Math.floor(cellY + (config.offsetY / 100) * cellH);

          // Extraire le portrait
          const portraitCanvas = document.createElement('canvas');
          portraitCanvas.width = pW;
          portraitCanvas.height = pH;
          const pCtx = portraitCanvas.getContext('2d');
          pCtx.drawImage(previewCanvas, x, y, pW, pH, 0, 0, pW, pH);

          // Verifier si l'image est vide (moyenne de luminosite)
          const imageData = pCtx.getImageData(0, 0, pW, pH);
          const brightness = getAverageBrightness(imageData);

          const dataUrl = portraitCanvas.toDataURL('image/png');
          const hash = await computePHash(portraitCanvas);

          extractedPortraits.push({
            index: row * config.cols + col,
            row,
            col,
            x, y, w: pW, h: pH,
            dataUrl,
            hash,
            name: '',
            isEmpty: brightness < 20 // Seuil pour images vides
          });
        }
      }

      renderGrid();
      updateStats();
      setStatus(`${extractedPortraits.length} portraits detectes. Cliquez "OCR Noms" pour extraire les noms automatiquement.`, 'success');
    }

    // ===== OCR des noms =====

    document.getElementById('btn-ocr-names').addEventListener('click', ocrAllNames);

    async function ocrAllNames() {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }

      if (extractedPortraits.length === 0) {
        setStatus('Detecter les portraits d\'abord', 'error');
        return;
      }

      setStatus('Initialisation OCR...', 'info');

      try {
        // Initialiser le worker Tesseract
        if (!ocrWorker) {
          ocrWorker = await Tesseract.createWorker('fra+eng', 1, {
            logger: m => {
              if (m.status === 'recognizing text') {
                const pct = Math.round(m.progress * 100);
                setStatus(`OCR en cours... ${pct}%`, 'info');
              }
            }
          });
        }

        // Zone de grille (avec marges)
        const gridStartX = loadedImage.width * (config.startX / 100);
        const gridStartY = loadedImage.height * (config.startY / 100);
        const gridW = loadedImage.width * (config.gridWidth / 100);
        const gridH = loadedImage.height * (config.gridHeight / 100);

        const cellW = gridW / config.cols;
        const cellH = gridH / config.rows;
        const nameY = cellH * (config.nameOffsetY / 100);
        const nameH = cellH * (config.nameHeight / 100);
        const rowGapPx = cellH * (config.rowGap / 100);

        let recognized = 0;
        const total = extractedPortraits.filter(p => !p.isEmpty).length;

        for (let i = 0; i < extractedPortraits.length; i++) {
          const p = extractedPortraits[i];
          if (p.isEmpty) continue;

          setStatus(`OCR ${recognized + 1}/${total}...`, 'info');

          // Calculer la zone de texte pour ce portrait
          const cellX = gridStartX + p.col * cellW;
          const cellY = gridStartY + p.row * cellH + p.row * rowGapPx;
          const textX = Math.floor(cellX + cellW * 0.05);
          const textY = Math.floor(cellY + nameY);
          const textW = Math.floor(cellW * 0.9);
          const textH = Math.floor(nameH);

          // Extraire la zone de texte
          const textCanvas = document.createElement('canvas');
          textCanvas.width = textW;
          textCanvas.height = textH;
          const tCtx = textCanvas.getContext('2d');
          tCtx.drawImage(previewCanvas, textX, textY, textW, textH, 0, 0, textW, textH);

          // Preprocesser pour OCR (augmenter contraste, inverser si fond sombre)
          preprocessForOCR(tCtx, textW, textH);

          // OCR
          const { data: { text } } = await ocrWorker.recognize(textCanvas);
          const cleanName = cleanOCRText(text);

          if (cleanName) {
            extractedPortraits[i].name = cleanName;
            extractedPortraits[i].ocrRaw = text.trim();
            recognized++;
          }
        }

        renderGrid();
        updateStats();
        setStatus(`OCR termine: ${recognized} noms reconnus sur ${total}`, 'success');

      } catch (e) {
        console.error('Erreur OCR:', e);
        setStatus('Erreur OCR: ' + e.message, 'error');
      }
    }

    function preprocessForOCR(ctx, w, h) {
      const imageData = ctx.getImageData(0, 0, w, h);
      const data = imageData.data;

      // Calculer la luminosite moyenne
      let totalBrightness = 0;
      for (let i = 0; i < data.length; i += 4) {
        totalBrightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
      }
      const avgBrightness = totalBrightness / (data.length / 4);

      // Si fond sombre (< 128), inverser les couleurs
      const invert = avgBrightness < 100;

      for (let i = 0; i < data.length; i += 4) {
        let gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];

        if (invert) {
          gray = 255 - gray;
        }

        // Augmenter le contraste
        gray = gray < 128 ? 0 : 255;

        data[i] = gray;
        data[i + 1] = gray;
        data[i + 2] = gray;
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function cleanOCRText(text) {
      if (!text) return '';

      // Nettoyer le texte OCR
      let clean = text.trim()
        .replace(/\n/g, ' ')           // Remplacer sauts de ligne
        .replace(/\s+/g, ' ')          // Normaliser espaces
        .replace(/[_|\\\/\[\]{}]/g, '') // Supprimer caracteres parasites
        .replace(/^[^a-zA-Z]+/, '')    // Supprimer prefixe non-alpha
        .replace(/[^a-zA-Z]+$/, '')    // Supprimer suffixe non-alpha
        .trim();

      // Ignorer les resultats trop courts ou avec trop peu de lettres
      const letters = clean.replace(/[^a-zA-Z]/g, '');
      if (letters.length < 3) return '';

      // Mettre en majuscules (comme dans le jeu)
      return clean.toUpperCase();
    }

    function getAverageBrightness(imageData) {
      const data = imageData.data;
      let sum = 0;
      for (let i = 0; i < data.length; i += 4) {
        sum += (data[i] + data[i + 1] + data[i + 2]) / 3;
      }
      return sum / (data.length / 4);
    }

    // ===== Mode manuel =====

    document.getElementById('btn-manual').addEventListener('click', () => {
      if (!loadedImage) {
        setStatus('Charger une image d\'abord', 'error');
        return;
      }
      isManualMode = true;
      manualMode.classList.add('visible');
      configPanel.classList.remove('visible');
      setStatus('Cliquez sur un portrait pour l\'extraire', 'info');
    });

    document.getElementById('btn-exit-manual').addEventListener('click', () => {
      isManualMode = false;
      manualMode.classList.remove('visible');
      const ctx = selectionCanvas.getContext('2d');
      ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
    });

    selectionCanvas.addEventListener('click', (e) => {
      if (!isManualMode || !loadedImage) return;

      const rect = selectionCanvas.getBoundingClientRect();
      const scaleX = loadedImage.width / rect.width;
      const scaleY = loadedImage.height / rect.height;

      const clickX = (e.clientX - rect.left) * scaleX;
      const clickY = (e.clientY - rect.top) * scaleY;

      const size = parseInt(document.getElementById('manual-size').value) || 64;
      const x = Math.floor(clickX - size / 2);
      const y = Math.floor(clickY - size / 2);

      extractManualPortrait(x, y, size);
    });

    async function extractManualPortrait(x, y, size) {
      // Limiter aux bords
      x = Math.max(0, Math.min(x, loadedImage.width - size));
      y = Math.max(0, Math.min(y, loadedImage.height - size));

      // Dessiner le rectangle de selection
      const ctx = selectionCanvas.getContext('2d');
      ctx.strokeStyle = '#51cf66';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, size, size);

      // Extraire
      const portraitCanvas = document.createElement('canvas');
      portraitCanvas.width = size;
      portraitCanvas.height = size;
      const pCtx = portraitCanvas.getContext('2d');
      pCtx.drawImage(previewCanvas, x, y, size, size, 0, 0, size, size);

      const dataUrl = portraitCanvas.toDataURL('image/png');
      const hash = await computePHash(portraitCanvas);

      // Demander le nom
      const name = prompt('Nom du personnage:');

      if (name && name.trim()) {
        extractedPortraits.push({
          index: extractedPortraits.length,
          x, y, w: size, h: size,
          dataUrl,
          hash,
          name: name.trim(),
          isEmpty: false,
          manual: true
        });

        renderGrid();
        updateStats();
        setStatus(`Portrait "${name.trim()}" ajoute`, 'success');
      }
    }

    // ===== Rendu =====

    function renderGrid() {
      grid.innerHTML = '';

      extractedPortraits.forEach((p, i) => {
        const card = document.createElement('div');
        card.className = 'portrait-card' + (p.isEmpty ? ' empty' : '');

        const ocrHint = p.ocrRaw && p.ocrRaw !== p.name ? `<div class="ocr-raw" title="OCR brut">${p.ocrRaw}</div>` : '';

        card.innerHTML = `
          <div class="index">#${p.index}</div>
          <img src="${p.dataUrl}" alt="Portrait ${i}" data-index="${i}">
          <input type="text" value="${p.name}" placeholder="Nom..." data-index="${i}">
          ${ocrHint}
          <div class="hash">${p.hash.substring(0, 8)}...</div>
        `;

        card.querySelector('input').addEventListener('change', (e) => {
          extractedPortraits[i].name = e.target.value.trim();
          updateStats();
        });

        card.querySelector('img').addEventListener('click', () => {
          // Highlight dans la preview
          if (p.x !== undefined) {
            const ctx = selectionCanvas.getContext('2d');
            ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
            ctx.strokeStyle = '#ffd43b';
            ctx.lineWidth = 3;
            ctx.strokeRect(p.x, p.y, p.w, p.h);
          }
        });

        grid.appendChild(card);
      });

      stats.classList.add('visible');
    }

    function updateStats() {
      const total = extractedPortraits.filter(p => !p.isEmpty).length;
      const named = extractedPortraits.filter(p => p.name && !p.isEmpty).length;
      countSpan.textContent = total;
      namedCountSpan.textContent = named;
    }

    // ===== pHash =====

    async function computePHash(canvas) {
      const hashSize = 8;
      const sampleSize = 32;

      const smallCanvas = document.createElement('canvas');
      smallCanvas.width = sampleSize;
      smallCanvas.height = sampleSize;
      const ctx = smallCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, 0, sampleSize, sampleSize);

      const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);
      const pixels = imageData.data;

      const gray = new Float32Array(sampleSize * sampleSize);
      for (let i = 0; i < gray.length; i++) {
        const offset = i * 4;
        gray[i] = 0.299 * pixels[offset] + 0.587 * pixels[offset + 1] + 0.114 * pixels[offset + 2];
      }

      const reduced = new Float32Array(hashSize * hashSize);
      const blockSize = sampleSize / hashSize;

      for (let y = 0; y < hashSize; y++) {
        for (let x = 0; x < hashSize; x++) {
          let sum = 0;
          let count = 0;
          const startY = Math.floor(y * blockSize);
          const endY = Math.floor((y + 1) * blockSize);
          const startX = Math.floor(x * blockSize);
          const endX = Math.floor((x + 1) * blockSize);

          for (let py = startY; py < endY; py++) {
            for (let px = startX; px < endX; px++) {
              sum += gray[py * sampleSize + px];
              count++;
            }
          }
          reduced[y * hashSize + x] = count > 0 ? sum / count : 0;
        }
      }

      const sorted = [...reduced].sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];

      let binary = '';
      for (let i = 0; i < reduced.length; i++) {
        binary += reduced[i] > median ? '1' : '0';
      }

      let hex = '';
      for (let i = 0; i < binary.length; i += 4) {
        hex += parseInt(binary.substr(i, 4), 2).toString(16);
      }

      return hex;
    }

    // ===== Export =====

    document.getElementById('btn-export').addEventListener('click', exportJSON);
    document.getElementById('btn-copy').addEventListener('click', copyToClipboard);
    document.getElementById('btn-clear').addEventListener('click', clearAll);

    function generateJSON() {
      const portraits = {};

      extractedPortraits.forEach(p => {
        if (p.name && p.name.trim() && !p.isEmpty) {
          portraits[p.hash] = p.name.trim();
        }
      });

      return JSON.stringify({
        description: "Portraits MSF",
        generatedAt: new Date().toISOString(),
        count: Object.keys(portraits).length,
        portraits
      }, null, 2);
    }

    function exportJSON() {
      const json = generateJSON();

      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `msf-portraits-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);

      output.textContent = json;
      output.style.display = 'block';

      const count = extractedPortraits.filter(p => p.name && !p.isEmpty).length;
      setStatus(`Exporte ${count} portraits`, 'success');
    }

    function copyToClipboard() {
      const json = generateJSON();
      navigator.clipboard.writeText(json).then(() => {
        setStatus('JSON copie', 'success');
      });
    }

    function clearAll() {
      extractedPortraits = [];
      grid.innerHTML = '';
      output.style.display = 'none';
      stats.classList.remove('visible');

      const ctx = selectionCanvas.getContext('2d');
      ctx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);

      const gctx = gridOverlay.getContext('2d');
      gctx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);

      setStatus('Liste effacee', 'info');
    }

    function setStatus(msg, type) {
      status.textContent = msg;
      status.className = type;
    }
  </script>
</body>
</html>
